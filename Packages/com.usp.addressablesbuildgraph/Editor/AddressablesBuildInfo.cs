using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using UnityEngine;
using UnityEngine.AddressableAssets.Initialization;
using UnityEngine.AddressableAssets.ResourceLocators;

using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.AddressableAssets.Build;
using UnityEditor.AddressableAssets.Build.BuildPipelineTasks;
using UnityEditor.AddressableAssets.Build.DataBuilders;
using UnityEditor.AddressableAssets.Settings;
using UnityEditor.AddressableAssets.Settings.GroupSchemas;
using UnityEditor.Build.Pipeline;
using UnityEditor.Build.Pipeline.Interfaces;
using UnityEditor.Build.Pipeline.Tasks;
using UnityEditor.Build.Content;
using UnityEngine.Serialization;
using UnityEngine.U2D;
using UnityEngine.AddressableAssets;
using UnityEditor.VersionControl;
using UnityEditor.Build.Utilities;
using System.Runtime.Remoting.Contexts;
using NUnit.Framework.Internal.Commands;
using NUnit.Framework;
using static UnityEditor.AddressableAssets.Build.Layout.BuildLayout;
using UnityEngine.Assertions;

namespace USP.AddressablesBuildGraph
{
    class AddressablesBuildInfo
    {
        #region Static Methods
        public static void Create(AddressableAssetsBuildContext aaBuildContext,
            IBundleWriteData bundleWriteData,
            out AddressablesBuildInfo buildInfo)
        {
            buildInfo = new AddressablesBuildInfo();

            using (Dictionary<string, string>.ValueCollection.Enumerator bundleNameEnumerator = bundleWriteData.FileToBundle.Values.GetEnumerator())
            using (Dictionary<string, List<ObjectIdentifier>>.ValueCollection.Enumerator objectIdentifierEnumerator = bundleWriteData.FileToObjects.Values.GetEnumerator())
            {
                // The bundle names and the object identifiers are ordered by the same archive files,
                // so they can be enumerated in tandem and treated as if they are zipped together:
                // a list of guids for assets, associated with the name of the bundle that there were built into.
                // (These asset guids represent all assets that were pulled into the build, not just the assets that were marked Addressable.)
                while (bundleNameEnumerator.MoveNext() && objectIdentifierEnumerator.MoveNext())
                {
                    // Pack the current bundle name in an info object.
                    var bundleInfo = new AssetBundleInfo(bundleNameEnumerator.Current);

                    // Add the bundle to the unique set of bundles that are generated by the build.
                    buildInfo.AssetBundles.Add(bundleInfo);

                    // Get the current list of assets that are in associated with the bundle.
                    List<ObjectIdentifier> objectIdentifierList = objectIdentifierEnumerator.Current;

                    buildInfo.Assets.EnsureCapacity(objectIdentifierList.Count);

                    // For every the object identifier in the list, perform the following:
                    foreach (ObjectIdentifier objectIdentifier in objectIdentifierList)
                    {
                        // Create a new instance of the info that defines the properties of the asset.
                        AssetInfo asset = AssetInfo.Create(objectIdentifier.guid, bundleWriteData.AssetToFiles, aaBuildContext.Settings);

                        /// Add the asset to the unique set of assets that are packed into the asset bundle.
                        bundleInfo.Assets.Add(asset);

                        // Add the bundle to the unique set of bundles that the asset is packed into.
                        // (Multiple bundles indicate that the asset is being duplicated).
                        asset.Bundles.Add(bundleInfo);

                        // Add the asset to the unique set of all assets used to generate the build.
                        buildInfo.Assets.Add(asset);
                    }
                }
            }

            // For every Addressables group in the list, perform the following:
            foreach (AddressableAssetGroup group in aaBuildContext.Settings.groups)
            {
                // Attempt to find the list of asset bundle names that are associated with the group.
                bool found = aaBuildContext.assetGroupToBundles.TryGetValue(group, out List<string> bundleNames);

                // If there was no list of asset bundle names associated with the group, then:
                if (!found)
                {
                    // Move on to the next group in the collection.
                    continue;
                }

                var groupInfo = new GroupInfo(group);

                // Add the group to the unique set of all Addressbles groups used to generate the build.
                buildInfo.Groups.Add(groupInfo);

                // Otherwise, there was a list of asset bundle names that are associated with the group.

                // For every bundle name associated with the group, perform the following:
                foreach (string bundleName in bundleNames)
                {
                    var key = new AssetBundleInfo(bundleName);
                    found = buildInfo.AssetBundles.TryGetValue(key, out AssetBundleInfo bundleInfo);

                    if (!found)
                    {
                        // NOTE: This shouldn't happen. Should we throw an error instead?

                        bundleInfo = key;
                        buildInfo.AssetBundles.Add(bundleInfo);
                    }

                    bundleInfo.Group = groupInfo;

                    groupInfo.AssetBundles.Add(bundleInfo);
                }
            }

            AssetInfo.PopulateAssetDependencyGraph(buildInfo.Assets);
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets a unique set of all Addressbles groups used to generate the build.
        /// </summary>
        public HashSet<GroupInfo> Groups { get; } = new HashSet<GroupInfo>();

        /// <summary>
        /// Gets a unique set of all assets used to generate the build.
        /// </summary>
        public HashSet<AssetInfo> Assets { get; } = new HashSet<AssetInfo>();

        /// <summary>
        /// Gets a unique set of all bundles generated by the build.
        /// </summary>
        public HashSet<AssetBundleInfo> AssetBundles { get; } = new HashSet<AssetBundleInfo>();
        #endregion
    }
}